# code.py — Démos lumineuses « autonomes » 8×8 (ESP32-S3 + CircuitPython)
# But : afficher plusieurs animations colorées sur une matrice de 8×8 LED.

import time, math, random
import board
import neopixel

# ───────── Réglages de base de la matrice ─────────
WIDTH = HEIGHT = 8               # 8 colonnes × 8 lignes
N = WIDTH * HEIGHT               # nombre total de LED
BRIGHTNESS = 0.02                # luminosité (montez si trop sombre)
PIXEL_ORDER = neopixel.GRB       # changez en RGB si les couleurs sont inversées

# Orientation de l’affichage (à ajuster si l’image est « tournée »)
SERPENTINE = True                # True si les rangées alternent le sens (très courant)
REVERSE_Y  = True                # True si le haut/bas semble inversé

# Connexion de la matrice (la plupart des cartes Waveshare utilisent IO48)
try:
    PIX = neopixel.NeoPixel(board.NEOPIXEL, N, brightness=BRIGHTNESS,
                            auto_write=False, pixel_order=PIXEL_ORDER)
except AttributeError:
    PIX = neopixel.NeoPixel(board.IO48, N, brightness=BRIGHTNESS,
                            auto_write=False, pixel_order=PIXEL_ORDER)

# ───────── Outils couleur et placement des pixels ─────────
GAMMA = 2.2  # adoucit la variation de lumière (gardez tel quel)

def clamp01(v):
    return 0.0 if v < 0.0 else 1.0 if v > 1.0 else v

def g8(v):
    # convertit une intensité 0..1 en 0..255 avec correction gamma
    v = clamp01(v)
    return int((v ** (1.0 / GAMMA)) * 255 + 0.5)

def hsv_to_rgb(h, s, v):
    # couleurs pratiques : on part d’une teinte (h) et on règle saturation (s) et lumière (v)
    h = (h % 1.0) * 6.0
    i = int(h)
    f = h - i
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    if   i == 0: r, g, b = v, t, p
    elif i == 1: r, g, b = q, v, p
    elif i == 2: r, g, b = p, v, t
    elif i == 3: r, g, b = p, q, v
    elif i == 4: r, g, b = t, p, v
    else:        r, g, b = v, p, q
    return (g8(r), g8(g), g8(b))

def fill_black():
    # éteint toutes les LED
    PIX.fill((0, 0, 0))
    PIX.show()

def px(x, y, color):
    # allume une LED logique (x,y) en tenant compte du câblage
    if x < 0 or x >= WIDTH or y < 0 or y >= HEIGHT:
        return
    if REVERSE_Y:
        y = (HEIGHT - 1) - y
    if SERPENTINE and (y & 1):
        x = (WIDTH - 1) - x
    PIX[y * WIDTH + x] = color

def heat_to_rgb(h):
    # palette « feu » simple : 0 = sombre, 1 = très chaud
    h = clamp01(h)
    if h < 0.33:
        v = h / 0.33
        r, g, b = v, 0.0, 0.0
    elif h < 0.66:
        v = (h - 0.33) / 0.33
        r, g, b = 1.0, v * 0.6, 0.0
    else:
        v = (h - 0.66) / 0.34
        r, g, b = 1.0, 0.6 + 0.4 * v, 0.3 * v
    return (g8(r), g8(g), g8(b))

# ───────── Animations (vous pouvez juste lancer et regarder) ─────────
def demo_aurore(duration=6.0, speed=0.25):
    # rideaux colorés qui ondulent doucement
    t0 = time.monotonic()
    while time.monotonic() - t0 < duration:
        t = time.monotonic() * speed
        for y in range(HEIGHT):
            for x in range(WIDTH):
                v = 0.55 + 0.45 * math.sin(2*math.pi*(x/7.0 + 0.35*math.sin(y/5.0 + t)))
                hue = 0.45 + 0.12*math.sin(t*0.7 + y*0.3)
                px(x, y, hsv_to_rgb(hue, 0.8, clamp01(v)))
        PIX.show()

def demo_kaleido(duration=6.0, speed=0.9):
    # on dessine un quart de l’image puis on le reflète pour faire un kaléidoscope
    t0 = time.monotonic()
    while time.monotonic() - t0 < duration:
        t = (time.monotonic() - t0) * speed
        for y in range(HEIGHT//2 + 1):
            for x in range(WIDTH//2 + 1):
                dx, dy = x - 3.5, y - 3.5
                d = math.sqrt(dx*dx + dy*dy)
                v = 0.2 + 0.8*clamp01(0.5 + 0.5*math.sin(3.0*d - t*2.2))
                hue = (t*0.08 + d*0.05) % 1.0
                c = hsv_to_rgb(hue, 0.9, v)
                for sx, sy in (
                    (x, y),
                    (WIDTH-1-x, y),
                    (x, HEIGHT-1-y),
                    (WIDTH-1-x, HEIGHT-1-y),
                ):
                    px(sx, sy, c)
        PIX.show()

def demo_pluie_etoiles(duration=5.0, densite=0.35, chute=0.65, fade=0.80):
    # des points apparaissent en haut et « tombent » en laissant une traînée
    buf = [0.0]*N
    t0 = time.monotonic()

    def put_from_buf():
        for yy in range(HEIGHT):
            for xx in range(WIDTH):
                v = clamp01(buf[yy*WIDTH + xx])
                px(xx, yy, hsv_to_rgb(0.58, 0.7, v))
        PIX.show()

    while time.monotonic() - t0 < duration:
        # apparition en haut
        for x in range(WIDTH):
            if random.random() < densite/WIDTH:
                buf[x] = 1.0
        # descente + atténuation
        for y in range(HEIGHT-1, 0, -1):
            for x in range(WIDTH):
                i = y*WIDTH + x
                j = (y-1)*WIDTH + x
                buf[i] = max(buf[i]*fade, buf[j]*chute)
        put_from_buf()
        # légère diffusion gauche/droite
        for y in range(HEIGHT):
            for x in range(1, WIDTH-1):
                i = y*WIDTH + x
                buf[i] = (buf[i] + 0.25*(buf[y*WIDTH + (x-1)] + buf[y*WIDTH + (x+1)])) / 1.5

def demo_feu(duration=6.0, refroid=0.03):
    # feu stylisé : du « chaud » apparaît en bas et monte en refroidissant
    heat = [0.0]*N
    t0 = time.monotonic()
    while time.monotonic() - t0 < duration:
        for x in range(WIDTH):
            heat[(HEIGHT-1)*WIDTH + x] = random.uniform(0.6, 1.0)
        for y in range(HEIGHT-2, -1, -1):
            for x in range(WIDTH):
                s = heat[(y+1)*WIDTH + x]
                if x > 0:       s += heat[(y+1)*WIDTH + (x-1)]
                if x < WIDTH-1: s += heat[(y+1)*WIDTH + (x+1)]
                s *= 0.333
                heat[y*WIDTH + x] = max(0.0, s - refroid)
        for y in range(HEIGHT):
            for x in range(WIDTH):
                px(x, y, heat_to_rgb(heat[y*WIDTH + x]))
        PIX.show()

def demo_comete_orbitale(duration=5.0, trail=0.82):
    # une « comète » tourne sur le bord de la matrice et laisse une traînée
    path = []
    for x in range(WIDTH):               path.append((x, 0))
    for y in range(1, HEIGHT):           path.append((WIDTH-1, y))
    for x in range(WIDTH-2, -1, -1):     path.append((x, HEIGHT-1))
    for y in range(HEIGHT-2, 0, -1):     path.append((0, y))
    buf = [0.0]*N
    t0 = time.monotonic()
    k = 0
    while time.monotonic() - t0 < duration:
        for i in range(N): buf[i] *= trail
        x, y = path[k % len(path)]
        buf[y*WIDTH + x] = 1.0
        hue = (k / len(path)) % 1.0
        for yy in range(HEIGHT):
            for xx in range(WIDTH):
                v = clamp01(buf[yy*WIDTH + xx])
                px(xx, yy, hsv_to_rgb(hue, 1.0, v))
        PIX.show()
        k += 1
        time.sleep(0.02)

def demo_bulles(duration=6.0, spawn=0.20, grow=0.18):
    # des anneaux (« bulles ») naissent, grandissent puis s’effacent
    bubbles = []  # (centre_x, centre_y, rayon, intensité)
    t0 = time.monotonic()
    base_hue = random.random()
    while time.monotonic() - t0 < duration:
        if random.random() < spawn:
            bubbles.append([random.uniform(1.0, 6.0), random.uniform(1.0, 6.0), 0.5, 1.0])
        PIX.fill((0,0,0))
        for b in list(bubbles):
            cx, cy, r, a = b
            r += grow; a *= 0.92
            b[2], b[3] = r, a
            for y in range(HEIGHT):
                for x in range(WIDTH):
                    dx, dy = x - cx, y - cy
                    d = math.sqrt(dx*dx + dy*dy)
                    if abs(d - r) < 0.45:      # pixels proches du cercle
                        hue = (base_hue + 0.12*r) % 1.0
                        col = hsv_to_rgb(hue, 0.7, clamp01(0.9*a))
                        px(x, y, col)
            if a < 0.06 or r > 6.0:
                bubbles.remove(b)
        PIX.show()
        time.sleep(0.02)

def demo_vortex(duration=6.0, speed=0.9):
    # tourbillon : couleur selon l’angle, lumière selon la distance au centre
    cx, cy = (WIDTH-1)/2.0, (HEIGHT-1)/2.0
    t0 = time.monotonic()
    while time.monotonic() - t0 < duration:
        t = (time.monotonic() - t0) * speed
        for y in range(HEIGHT):
            for x in range(WIDTH):
                ang = math.atan2(y - cy, x - cx)
                dx, dy = x - cx, y - cy
                dist = math.sqrt(dx*dx + dy*dy)
                hue = (ang/(2*math.pi) + 0.5 + 0.15*t) % 1.0
                val = clamp01(1.0 - dist/4.2) ** 1.5
                px(x, y, hsv_to_rgb(hue, 1.0, val))
        PIX.show()

# ───────── Lancement des démos (en boucle) ─────────
DEMOS = [
    lambda: demo_aurore(duration=6.0, speed=0.28),
    lambda: demo_kaleido(duration=6.0, speed=1.0),
    lambda: demo_pluie_etoiles(duration=5.0, densite=0.40, chute=0.70, fade=0.82),
    lambda: demo_feu(duration=6.0, refroid=0.035),
    lambda: demo_comete_orbitale(duration=5.0, trail=0.86),
    lambda: demo_bulles(duration=6.0, spawn=0.22, grow=0.20),
    lambda: demo_vortex(duration=6.0, speed=1.0),
]

def run_show():
    # enchaîne toutes les démos avec une courte pause noire
    while True:
        for d in DEMOS:
            d()
            fill_black()
            time.sleep(0.18)

# ───────── Démarrage ─────────
try:
    # petit test : rouge → vert → bleu pour vérifier que la matrice répond
    PIX.fill((40,0,0)); PIX.show(); time.sleep(0.15)
    PIX.fill((0,40,0)); PIX.show(); time.sleep(0.15)
    PIX.fill((0,0,40)); PIX.show(); time.sleep(0.15)
    fill_black()

    run_show()
except KeyboardInterrupt:
    fill_black()
    raise


# code.py — Dé électronique sur matrice 8×8
# Quand on secoue la carte, un nombre aléatoire de 1 à 6 est choisi
# et les points du dé s’affichent correctement.

import time, math, random
import board, busio, neopixel
from adafruit_pixel_framebuf import PixelFramebuffer, VERTICAL
import qmi8658c

# ────────── Réglages de la matrice de LED ──────────
L = H = 8                       # matrice = 8 colonnes × 8 lignes
BRIGHTNESS = 0.03               # luminosité des LED (0.01 = faible, 0.1 = fort)

pixels = neopixel.NeoPixel(board.NEOPIXEL, L*H,
    brightness=BRIGHTNESS, auto_write=False)

fb = PixelFramebuffer(pixels, L, H,
    orientation=VERTICAL, reverse_y=True)

# Couleurs
NOIR  = 0x000000
BLANC = 0xFFFFFF

# ────────── Capteur de mouvement ──────────
# Le capteur (IMU) mesure l’accélération → permet de détecter une secousse
i2c = busio.I2C(board.IMU_SCL, board.IMU_SDA)
imu = qmi8658c.QMI8658C(i2c)

SHAKE_THRESH = 3.8   # sensibilité : plus bas = plus sensible
DEBOUNCE_MS  = 600   # délai pour éviter deux secousses trop rapprochées

# ────────── Positions des points du dé ──────────
# Chaque point (pip) est un petit carré 2×2.
# On utilise une grille espacée (0, 3, 6) pour éviter que les points se touchent.
DOT_SIZE = 2
G = [0, 3, 6]

# La matrice est miroir → on corrige la position en inversant l’axe X.
def mx(x):
    return (L - DOT_SIZE - x)

# Emplacements possibles
P = {
    "TL": (mx(G[0]), G[0]),  # haut-gauche
    "TR": (mx(G[2]), G[0]),  # haut-droit
    "ML": (mx(G[0]), G[1]),  # milieu-gauche
    "MM": (mx(G[1]), G[1]),  # centre
    "MR": (mx(G[2]), G[1]),  # milieu-droit
    "BL": (mx(G[0]), G[2]),  # bas-gauche
    "BR": (mx(G[2]), G[2]),  # bas-droit
}

# Combinaisons de points pour chaque face du dé
FACES = {
    1: ("MM",),
    2: ("TL", "BR"),
    3: ("TL", "MM", "BR"),
    4: ("TL", "TR", "BL", "BR"),
    5: ("TL", "TR", "MM", "BL", "BR"),
    6: ("TL", "TR", "ML", "MR", "BL", "BR"),
}

def dessiner_point(x, y, couleur=BLANC):
    """Allume un carré 2×2 de LED à la position (x,y)."""
    fb.fill_rect(x, y, DOT_SIZE, DOT_SIZE, couleur)

def dessiner_face(n):
    """Efface la matrice et affiche la face n du dé."""
    fb.fill(NOIR)
    for key in FACES[n]:
        x, y = P[key]
        dessiner_point(x, y)
    fb.display()

# ────────── Détection de secousse ──────────
def secousse_detectee():
    """Retourne True si la carte est secouée."""
    try:
        ax, ay, az = imu.acceleration
    except Exception:
        return False
    g = math.sqrt(ax*ax + ay*ay + az*az)
    return abs(g - 9.8) > SHAKE_THRESH

# ────────── Programme principal ──────────
def main():
    # petit clignotement au démarrage
    fb.fill(0x202020); fb.display(); time.sleep(0.2)
    fb.fill(NOIR); fb.display(); time.sleep(0.1)

    # face de départ
    face = 1
    dessiner_face(face)

    last_ms = 0.0
    while True:
        now_ms = time.monotonic() * 1000.0

        # si on secoue la carte et que le délai est respecté
        if (now_ms - last_ms) > DEBOUNCE_MS and secousse_detectee():
            last_ms = now_ms
            # tirage d’un nombre aléatoire
            face = random.randint(1, 6)
            dessiner_face(face)

            # petit flash rapide pour confirmer le tirage
            time.sleep(0.06)
            fb.fill(NOIR); fb.display(); time.sleep(0.06)
            dessiner_face(face)

        time.sleep(0.02)  # boucle douce

# Lancement du programme
try:
    main()
except KeyboardInterrupt:
    fb.fill(NOIR); fb.display()
    raise
